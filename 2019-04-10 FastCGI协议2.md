baiyan

全部视频：https://segmentfault.com/a/1190000018488313

## 引入
 - 读这篇文章之前请先阅读[【PHP源码学习】2019-04-09 FastCGI协议1](https://segmentfault.com/a/1190000019767015)
 - 我们知道，客户端、nginx、PHP-FPM之间通信的方式如下：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/7/17/1563331385845.png)
 - 那么，我们今天详细解释一下图中的FastCGI协议的部分。学习一个协议，最重要的就是它的格式与语法，看它如何组织所要传输数据的格式，让接收方能够更加方便地接收。那么，这个协议需要解决如下几个问题：

>  - 标识一个请求的开始与结束，让数据包在繁杂的TCP数据流中拥有清晰的边界，方便读取
>  - 传输其他附加参数（如定义在nginx中的fastcgi_param各项参数）
>  - 传输一个客户端发来请求的原始数据

 - 针对上面最后一点的额外的参数，有如下一些形式，大家应该比较熟悉了：
```nginx
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;#脚本文件请求的路径,也就是说当访问127.0.0.1/index.php的时候，需要读取网站根目录下面的index.php文件，如果没有配置这一配置项时，nginx不回去网站根目录下访问.php文件，所以返回空白
fastcgi_param QUERY_STRING $query_string;                        #请求的参数;如?app=123
fastcgi_param REQUEST_METHOD $request_method;                    #请求的动作(GET,POST)
fastcgi_param CONTENT_TYPE $content_type;                        #请求头中的Content-Type字段
fastcgi_param CONTENT_LENGTH $content_length;                    #请求头中的Content-length字段。

fastcgi_param SCRIPT_NAME $fastcgi_script_name;                  #脚本名称 
fastcgi_param REQUEST_URI $request_uri;                          #请求的地址不带参数
fastcgi_param DOCUMENT_URI $document_uri;                        #与$uri相同。 
fastcgi_param DOCUMENT_ROOT $document_root;                      #网站的根目录。在server配置中root指令中指定的值 
fastcgi_param SERVER_PROTOCOL $server_protocol;                  #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。

fastcgi_param GATEWAY_INTERFACE CGI/1.1;                         #cgi 版本
fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;              #nginx 版本号，可修改、隐藏

fastcgi_param REMOTE_ADDR $remote_addr;                          #客户端IP
fastcgi_param REMOTE_PORT $remote_port;                          #客户端端口
fastcgi_param SERVER_ADDR $server_addr;                          #服务器IP地址
fastcgi_param SERVER_PORT $server_port;                          #服务器端口
fastcgi_param SERVER_NAME $server_name;                          #服务器名，域名在server配置中指定的server_name

fastcgi_param PATH_INFO $path_info;                             #可自定义变量

-- PHP only, required if PHP was built with --enable-force-cgi-redirect
fastcgi_param REDIRECT_STATUS 200;
```
 - 那么，我们在PHP中即可打印出上面的服务环境变量。如：
```php
echo $_SERVER['REMOTE_ADDR']
```
 - 带着以上几个问题，我们来由外到内一步步剖析为什么FastCGI协议是这样设计的
## FastCGI的设计思想与结构
 - 首先我们基于之前的客户端、nginx、PHP-FPM之间通信流程图，放大nginx与PHP-FPM之间通信的数据流：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/7/17/1563332386398.png)
 - 为了解决我们之前谈到的三个问题，FastCGI把包分为多种类型，每种类型做它自己的事情。如图中的FCGI_BEGIN_REQUEST类型，负责标识请求的开始，FCGI_PARAMS类型负责发送nginx中配置的参数，FCGI_STDIN类型存储客户端发送的原始字节流数据。这样一次请求的所有数据才能够成功送达到PHP-FPM。我们看一下FastCGI数据包的所有类型：
```c
#define FCGI_BEGIN_REQUEST       1                     //(web->fastcgi)请求开始数据包
#define FCGI_ABORT_REQUEST       2                     //(web->fastcgi)终止请求
#define FCGI_END_REQUEST         3                     //(fastcgi->web)请求结束
#define FCGI_PARAMS              4                     //(web->fastcgi)传递参数
#define FCGI_STDIN               5                     //(web->fastcgi)数据流传输数据
#define FCGI_STDOUT              6                     //(fastcgi->web)数据流传输数据
#define FCGI_STDERR              7                     //(fastcgi->web)数据流传输
#define FCGI_DATA                8                     //(web->fastcgi)数据流传输
#define FCGI_GET_VALUES          9                     //(web->fastcgi)查询fastcgi服务器性能参数
#define FCGI_GET_VALUES_RESULT  10                     //(fastcgi->web)fastcgi性能参数查询返回
#define FCGI_UNKNOWN_TYPE       11
#define FCGI_MAXTYPE (FCGI_UNKNOWN_TYPE)
```
 - 我们从宏观层面看完了FastCGI包，我们深入每个包的内部结构。通过上一篇笔记的学习我们知道，TCP/IP等协议的数据包，通常都是数据包**头部+包体**的结构，头部字段通常是一些描述信息，包体才真正地存储数据，这里FastCGI协议也不例外：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/7/17/1563336273404.png)
### FastCGI数据包头部
```c
typedef struct {
    unsigned char version;            // 协议版本号
    unsigned char type;               // 数据包类型
    unsigned char requestIdB1;        // 包唯一标识id的高8位
    unsigned char requestIdB0;        // 包唯一标识id的低8位
    unsigned char contentLengthB1;    // 记录内容长度高8位(body长度高8位)
    unsigned char contentLengthB0;    // 记录内容长度低8位(body长度低8位)
    unsigned char paddingLength;      // 补齐位长度(body补齐长度)
    unsigned char reserved;           // 字节补齐位
}Header;
```
 - 通常情况下，每一个FastCGI数据包都有一个头部，大小为8个字节，用来记录当前数据包的一些辅助信息，如数据包类型（需要确认当前包属于刚才我们列举的哪种类型）、唯一标识包的id、还有包体的长度、以及字节对齐（确保是2的整数次幂）
 - 虽然通常情况下，每一种FastCGI类型的数据包都有相同结构的头部，但是每一种类型之间包体部分的结构就不太一样了。
### FCGI_BEGIN_REQUEST
 - 由于数据包头部的结构已经介绍完毕了，接下来我们看一下FCGI_BEGIN_REQUEST类型包体部分的结构，它是一个结构体：
```c 
typedef struct _fcgi_begin_request {
	unsigned char roleB1; //
	unsigned char roleB0;
	unsigned char flags;
	unsigned char reserved[5];
} fcgi_begin_request;
```
 - 其中role字段是为了描述当前需要FastCGI服务器（即 PHP-FPM）充当的角色，有FCGI_RESPONDER，FCGI_AUTHORIZER 和FCGI_FILTER。

> FCGI_RESPONDER：最常见的动态语言脚本处理角色，叫做响应器。
> FCGI_AUTHORIZER：用于判断请求是否拥有访问权限，类似于HTTP请求中的认证功能，叫做授权器。
> FCGI_FILTER：用于对一些特殊的数据进行处理并返回，包括添加数据头部与尾部等功能，叫做过滤器（官方对其没有过多的介绍，所以无法详细描述）。
> 大多数请求我们都是使用FCGI_RESPONDER角色进行请求传输，因为动态语言可以完全的替代其他2中角色的功能，所以授权器和过滤器的功能被大家给遗忘了。不过这不代表角色的设定是错误的，角色的设定很大一部分程度上给Fastcgi协议提供了快捷扩展的功能，保证了协议的可扩展性。
> flags则是用于设置使用传输时复用通道，避免每次传输都需要新开一个socket通道来浪费时间和性能。

### FCGI_PARAMS
 - 接下来我们看下一个类型数据包，即FCGI_PARAMS的包体结构：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/7/17/1563337362669.png)