baiyan

## 套接字是什么
我们常常使用HTTP协议来传输各种格式的数据，其实底层是基于传输层TCP协议来实现的。TCP协议仅仅把这些数据当做一串无意义的数据流来看待。所以，我们可以说：**客户端与服务器通过在建立的连接上发送字节流来进行通信**。
这种C/S架构的通信机制，需要标识通信双方的网络地址和端口号信息。对于客户端来说，需要知道我的数据接收方位置，我们用网络地址和端口来唯一标识一个服务端实体；对于服务端来说，需要知道数据从哪里来，我们同样用网络地址和端口来唯一标识一个客户端实体。那么，用来唯一标识通信两端的数据结构就叫做套接字。一个连接可以由它两端的套接字地址唯一确定：
```
(客户端地址:客户端端口号，服务端地址:服务端端口号)
```
有了通信双方的地址信息之后，就可以进行数据传输了。那么我们现在需要一个规范，来规定通信双方的连接及数据传输过程。在Unix系统中，实现了一套套接字接口，用来描述和规范双方通信的整个过程。

>  - socket()：创建一个套接字描述符
>  - connect()：客户端通过调用connect函数来建立和服务器的连接
>  - bind()：告诉内核将socket()创建的套接字与某个服务端地址与端口连接起来，后续会对这个地址和端口进行监听
>  - listen()：告诉内核，将这个套接字当成服务器这种被动实体来看待(服务器是等待客户端连接的被动实体，而内核认为socket()创建的套接字默认是主动实体，所以才需要listen()函数，告诉内核进行主动到被动实体的转换)
>  - accept()：等待客户端的连接请求并返回一个新的已连接描述符

## 从最简单的服务器说起
由于Unix的历史遗留问题，原始的套接字接口对地址和端口等数据封装并不简洁，为了简化这些我们不关注的细节而只关注整个流程，我们使用PHP来进行分析。PHP对Unix的socket相关接口进行了封装，所有相关套接字的函数都被加上了socket_前缀。一个PHP实现的简单服务器伪代码如下：
```php
<?php

if (($listenSocket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP))=== false) {
    echo '套接字创建失败';
}
if (socket_bind($listenSocket, '127.0.0.1', 8888) === false) {
    echo '绑定地址与端口失败';
}
if (socket_listen($listenSocket) === false) {
    echo '转换主动套接字到被动套接字失败';
}
while (1) {
    if (($connSocket = socket_accept($listenSocket)) === false) {
        echo '客户端的连接请求还没有到达';
    } else {
		socket_close($listenSocket); //释放监听套接字
        socket_read($connSocket);  //读取客户端数据
        socket_write($connSocket); //给客户端返回数据
		
    }
    socket_close($connSocket);
}
```
我们梳理一下这个简单的服务器创建流程：

>  - socket_create()：创建一个套接字，这个套接字就代表建立的连接上的一个端点。第一个参数AF_INET为使用的底层协议为IPv4；第二个参数SOCK_STREAM表示使用字节流进行数据传输；第三个参数SQL_TCP代表本层协议为TCP协议。这里创建的套接字只是一个连接上的端点的一个**抽象**概念。
>  - socket_bind()：绑定这个套接字到一个具体的服务器地址和端口上，真正**实例化**这个套接字。参数就是你之前创建的一个抽象的套接字，还有你具体的网络地址和端口。
>  - socket_listen()：我们观察到只有一个函数参数就是之前创建的套接字。有些同学之前可能认为这一步函数调用完全没有必要。但是它告诉内核，我是一个服务器，将套接字转换为一个被动实体，其实是有很大的作用的。
>  - socket_accept()：接收客户端发来的请求。因为服务器启动之后，是不知道客户端什么时候有连接到来的。所以，需要在一个while循环中不断调用这个函数，如果有连接请求到来，那么就会返回一个新的套接字，我们可以通过这个新的套接字进行与客户端的数据通信，如果没有，就只能不断地进行循环，直到有请求到来为止。

注意，在这里我将套接字分为两类，一个是监听套接字，一个是连接套接字。注意这里对两种套接字的区分，在下面的讨论中会用到：

>  - 监听套接字：服务器对某个端口进行监听，这个套接字用来表示这个端口($listenSocket)
>  - 连接套接字：服务器与客户端已经建立连接，所有的读写操作都要在连接套接字上进行($connSocket)

那么我们对这个服务器进行分析，它存在什么问题呢？

> **一个这样的服务器进程只能同时处理一个客户端连接**。因为一旦有请求到来，我们就只能进行与当前客户端的通信过程，整个流程是阻塞的，在与当前客户端连接进行读写数据的过程中，我们就无法对其它客户端的连接请求进行处理了。

## IO并发性能提升之路
由于上述服务器的性能太烂，所以优秀的开发者们想出了以下几种方案，用以提升服务器的效率，分别是：

>  - 多进程
>  - 多线程
>  - 基于单进程的IO多路复用（select/poll/epoll）

### 多进程
由于之前我们的服务器是单进程的，所以一个客户端连接过来，这个进程就要去处理与当前客户端的连接请求。那么如何去优化呢？很简单，一个进程不行，那搞很多个进程不就可以同时处理多个客户端了吗？我们想了想，写出了代码：
```php
<?php

if (($listenSocket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP))=== false) {
    echo '套接字创建失败';
}
if (socket_bind($listenSocket, '127.0.0.1', 8888) === false) {
    echo '绑定地址与端口失败';
}
if (socket_listen($listenSocket) === false) {
    echo '转换主动套接字到被动套接字失败';
}
for ($i = 0; $i < 10; $i++) { //初始创建10个子进程
    if (pcntl_fork() == 0) {
        if (($connSocket = socket_accept($listenSocket)) === false) {
            echo '客户端的连接请求还没有到达';
        } else {
			socket_close($listenSocket); //释放监听套接字
            socket_read($connSocket);  //读取客户端数据
            socket_write($connSocket); //给客户端返回数据
        }
        socket_close($connSocket);
    }
}
```
我们主要关注这个for循环，一共循环了10次代表初始的子进程数量我们设置为10。接着我们调用了pcntl_fork()函数创建子进程。由于一个客户端的connect就对应一个服务端的accept。所以在每个fork之后的10个子进程中，我们均进行accept的系统调用，等待客户端的连接。这样，就可以通过10个服务器进程，同时接受10个客户端的连接、同时为10个客户端提供读写数据服务。
注意这样一个细节，由于所有子进程都是预先创建好的，那么请求到来的时候就不用创建子进程，也提高了每个连接请求的处理效率。同时也可以借助进程池的概念，这些子进程在处理完连接请求之后并不立即回收，可以继续服务下一个客户端连接请求，就不用重复的进行fork()的系统调用，也能够提高服务器的性能。这些小技巧在PHP-FPM的实现中都有所体现。其实这种进程创建方式是其三种运行模式中的一种，被称作static：

>  - ondemand：按需启动。PHP-FPM启动的时候不会启动任何一个子进程(worker进程)，只有客户端连接请求到达时才启动
>  - dynamic：在PHP-FPM启动时，会初始启动一些子进程，在运行过程中视情况动态调整worker数量
>  - static：PHP-FPM启动时，启动固定大小数量的子进程，在运行期间也不会扩容

回到正题，多进程这种方式的的确确解决了服务器在同一时间只能处理一个客户端连接请求的问题，但是这种基于多进程的客户端连接处理模式，仍存在以下劣势：

>  - fork()等系统调用会使得进程的上下文进行切换，效率很低
>  - 进程创建的数量随着连接请求的增加而增加。比如100000个请求，就要fork100000个进程，开销太大
>  - 进程与进程之间的地址空间是私有、独立的，使得进程之间的数据共享变得困难

既然谈到了多进程的数据共享与切换开销的问题，那么我们能够很快想到解决该问题的方法，就是化多进程为更轻量级的多线程。
### 多线程
线程是运行在进程上下文的逻辑流。一个进程可以包含多个线程，多个线程运行在单一的进程上下文中，因此共享这个进程的地址空间的所有内容，解决了进程与进程之间通信难的问题。同时，由于一个线程的上下文要比一个进程的上下文小得多，所以线程的上下文切换，要比进程的上下文切换效率高得多。线程是轻量级的进程，解决了进程上下文切换效率低的问题。
由于PHP中没有多线程的概念，所以我们仅仅把上面的伪代码中创建进程的部分，改成创建线程即可，代码大体类似，在此不再赘述。
### IO多路复用
IO多路复用这个名词看起来好像很复杂很高深的样子。实际上，这项技术所能带来的本质成果就是：**一个服务端进程可以同时处理多个客户端的连接**。
 - 多路：多个客户端连接。
 - 复用：从之前的使用多个进程到复用一个进程，就能够实现同时处理多个客户端的连接。
在之前的讲述中，一个服务端进程，只能同时处理一个连接。如果想同时处理多个客户端连接，需要多进程或者多线程的帮助，免不了上下文切换的开销。IO多路复用技术就解决了上下文切换的问题。IO多路复用技术的发展可以从select->poll->epoll来划分。
IO多路复用的原理的核心就在于它添加了一个类似**套接字管理员**的东西。之前说过，我们的监听套接字正在监听一个服务器上的端口。如果有多个客户端套接字连接到这个端口，那么我怎么知道哪个套接字已经可以建立连接了，以及这么多连接的建立顺序，我该如何把握？
#### select
最早的**套接字管理员**是select()系统调用。我们可以使用PHP为我们提供的socket_select()函数。它可以管理多个客户端连接套接字。如果有5个客户端调用了connect()，连接到了服务器的**监听套接字**（$listenSocket）上，这个监听套接字的状态就会从不可读变为可读。我们可以把这个监听套接字交给select管理员进行管理(通过传递几个数组参数)。一旦这5个客户端哪个套接字状态变为可读了(这个客户端可能已经成功调用了connect())，select()函数就会把准备就绪的服务器监听套接字返回给服务器进程。这样接下来，我们就可以直接进行accept系统调用来建立连接套接字($connSocket)。我们惊奇的发现，此时accept()函数竟然不会阻塞了！接下来，服务器进程就可以对其进行读写啦。