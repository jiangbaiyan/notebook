baiyan

全部视频：https://segmentfault.com/a/1190000018488313

## 处理垃圾缓冲区
 - 在上一篇文章中，我们将所有疑似垃圾的变量都放到缓冲区中，一直存下去，待存满缓冲区10000个存储单元之后，垃圾回收算法就会启动，对缓冲区中的所有疑似垃圾进行标记与清除。垃圾回收算法需要对这个缓冲区进行扫描遍历，判定每一个存储单元中的内容是否为最终的垃圾。
 - 回顾gc_possible_root()函数，我们将疑似垃圾存入了一个缓冲区中：
```c
ZEND_API void ZEND_FASTCALL gc_possible_root(zend_refcounted *ref)
{
	...
	if (newRoot) {
		GC_G(unused) = newRoot->prev;
	} else if (GC_G(first_unused) != GC_G(last_unused)) {
		newRoot = GC_G(first_unused);
		GC_G(first_unused)++;
	} else { //垃圾回收器存满了，才会启动垃圾回收算法
		if (!GC_G(gc_enabled)) {
			return;
		}
		GC_REFCOUNT(ref)++;
		gc_collect_cycles(); //真正启动垃圾回收算法
		GC_REFCOUNT(ref)--;
		...
	}
}
```
 - 由此可见，垃圾回收算法会在缓冲区存满的时候才会启动，这样会减少垃圾回收算法运行的频率，进而减小性能的损耗且提高效率（详见上一篇文章）
## 垃圾回收算法的运行
 - 在此之前，我们已经将垃圾缓冲区内的所有元素均标记成了紫色GC_PURPLE
```c
ZEND_API int zend_gc_collect_cycles(void)
{
		
		...
		//遍历垃圾回收器链表，对其进行深度优先遍历并将refcount减1，并把它们标记为灰色GC_GREY
		gc_mark_roots();
	
		//遍历垃圾回收器链表，判断每个疑似垃圾的元素的refcount是否>0，如果>0就不是垃圾，将其标记为黑色GC_BLACK，否则是垃圾，将其标记为白色GC_WHITE，它们是真正的垃圾，后面需要释放掉
		gc_scan_roots();
		...
		
		//对垃圾回收器中为白色GC_WHITE的垃圾
		count = gc_collect_roots(&gc_flags);

		GC_G(gc_active) = 0;

		if (GC_G(to_free).next == &GC_G(to_free)) {
			/* nothing to free */
			GC_TRACE("Nothing to free");
			return 0;
		}

		/* Copy global to_free list into local list */
		to_free.next = GC_G(to_free).next;
		to_free.prev = GC_G(to_free).prev;
		to_free.next->prev = &to_free;
		to_free.prev->next = &to_free;

		/* Free global list */
		GC_G(to_free).next = &GC_G(to_free);
		GC_G(to_free).prev = &GC_G(to_free);

		orig_next_to_free = GC_G(next_to_free);

		...

		if (gc_flags & GC_HAS_DESTRUCTORS) {
			GC_TRACE("Calling destructors");

			/* Remember reference counters before calling destructors */
			current = to_free.next;
			while (current != &to_free) {
				current->refcount = GC_REFCOUNT(current->ref);
				current = current->next;
			}

			/* Call destructors */
			current = to_free.next;
			while (current != &to_free) {
				p = current->ref;
				GC_G(next_to_free) = current->next;
				if (GC_TYPE(p) == IS_OBJECT) {
					zend_object *obj = (zend_object*)p;

					if (!(GC_FLAGS(obj) & IS_OBJ_DESTRUCTOR_CALLED)) {
						GC_TRACE_REF(obj, "calling destructor");
						GC_FLAGS(obj) |= IS_OBJ_DESTRUCTOR_CALLED;
						if (obj->handlers->dtor_obj
						 && (obj->handlers->dtor_obj != zend_objects_destroy_object
						  || obj->ce->destructor)) {
							GC_REFCOUNT(obj)++;
							obj->handlers->dtor_obj(obj);
							GC_REFCOUNT(obj)--;
						}
					}
				}
				current = GC_G(next_to_free);
			}

			/* Remove values captured in destructors */
			current = to_free.next;
			while (current != &to_free) {
				GC_G(next_to_free) = current->next;
				if (GC_REFCOUNT(current->ref) > current->refcount) {
					gc_remove_nested_data_from_buffer(current->ref, current);
				}
				current = GC_G(next_to_free);
			}
		}

		/* Destroy zvals */
		GC_TRACE("Destroying zvals");
		GC_G(gc_active) = 1;
		current = to_free.next;
		while (current != &to_free) {
			p = current->ref;
			GC_G(next_to_free) = current->next;
			GC_TRACE_REF(p, "destroying");
			if (GC_TYPE(p) == IS_OBJECT) {
				zend_object *obj = (zend_object*)p;

				EG(objects_store).object_buckets[obj->handle] = SET_OBJ_INVALID(obj);
				GC_TYPE(obj) = IS_NULL;
				if (!(GC_FLAGS(obj) & IS_OBJ_FREE_CALLED)) {
					GC_FLAGS(obj) |= IS_OBJ_FREE_CALLED;
					if (obj->handlers->free_obj) {
						GC_REFCOUNT(obj)++;
						obj->handlers->free_obj(obj);
						GC_REFCOUNT(obj)--;
					}
				}
				SET_OBJ_BUCKET_NUMBER(EG(objects_store).object_buckets[obj->handle], EG(objects_store).free_list_head);
				EG(objects_store).free_list_head = obj->handle;
				p = current->ref = (zend_refcounted*)(((char*)obj) - obj->handlers->offset);
			} else if (GC_TYPE(p) == IS_ARRAY) {
				zend_array *arr = (zend_array*)p;

				GC_TYPE(arr) = IS_NULL;

				/* GC may destroy arrays with rc>1. This is valid and safe. */
				HT_ALLOW_COW_VIOLATION(arr);

				zend_hash_destroy(arr);
			}
			current = GC_G(next_to_free);
		}

		/* Free objects */
		current = to_free.next;
		while (current != &to_free) {
			next = current->next;
			p = current->ref;
			if (EXPECTED(current >= GC_G(buf) && current < GC_G(buf) + GC_ROOT_BUFFER_MAX_ENTRIES)) {
				current->prev = GC_G(unused);
				GC_G(unused) = current;
			}
			efree(p);
			current = next;
		}

		while (GC_G(additional_buffer) != additional_buffer_snapshot) {
			gc_additional_buffer *next = GC_G(additional_buffer)->next;
			efree(GC_G(additional_buffer));
			GC_G(additional_buffer) = next;
		}

		GC_TRACE("Collection finished");
		GC_G(collected) += count;
		GC_G(next_to_free) = orig_next_to_free;
#if ZEND_GC_DEBUG
		GC_G(gc_full) = orig_gc_full;
#endif
		GC_G(gc_active) = 0;
	}

	return count;
}
```