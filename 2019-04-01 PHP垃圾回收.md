# **【PHP源码学习】2019-03-28 Zend虚拟机**
baiyan

全部视频：https://segmentfault.com/a/1190000018488313

## 垃圾回收的触发条件
 - 我们知道，在PHP中，如果一个变量的引用计数减少到0（没有任何地方在使用这个变量），它所占用的内存就会被PHP虚拟机自动回收，**并不会被当做垃圾**。垃圾回收的触发条件是当一个变量的引用计数不断减少之后，最终不为0（仍有地方在使用这个变量），才会触发垃圾回收。一个典型的例子就是**循环引用**，它让变量自己引用自己。看下面一个例子:
```
<?php
$a = ['time' => time()];
echo $a;
$a[] = &$a; //循环引用
echo $a;
unset($a);
echo $a;
```
 - 我们可以知道，unset($a)之后，$a的type类型变成了0(IS_UNDEF)，同时其指向的zend_reference结构体的refcount变为了1（因为$a数组中的元素仍然在引用它），我们画图来表示一下现在的内存情况：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/5/14/1557811356169.png)
 - 那么问题出现了，$a是unset掉了，但是由于原始的zend_array中的元素仍然在指向仍然在指向zend_reference结构体，所以zend_reference的refcount是1，而并非是预期的0。这样一来，这两个zend_reference与zend_array结构在unset($a)之后，仍然存在于内存之中，如果对此不作任何处理，就会造成**内存泄漏**。
 - 那么如何解决循环引用带来的内存泄漏问题呢？**垃圾回收**就要派上用场了。在PHP7中，如果检测到refcount--后仍 > 0的变量，会把它放入一个双向链表中，等待垃圾回收。这个双向链表相当于一个缓冲区的作用。待缓冲区满了之后（10000个存储单元），然后再对其进行标记和清除（后面会在代码层面具体讲垃圾回收的方法）。而这个缓冲区的作用就是减少垃圾回收算法运行的频率，减少对正在运行的服务端代码的影响，下面我们来详细讲解。