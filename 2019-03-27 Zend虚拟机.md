# **【PHP源码学习】2019-03-27 Zend虚拟机**
baiyan

全部视频：https://segmentfault.com/a/1190000018488313

原视频地址：http://replay.xesv5.com/ll/2480/73533b76eb889194db9d5b922669f6c4.flv.mp4

## 引入
 - 我们知道，在经过编译阶段（zend_compile函数）中，我们生成AST并对其遍历，生成一条条指令，其所有的指令均存在op_array中，每一条指令都是一个opline。那么指令既然已经生成完毕，接下来的任务就要交给zend虚拟机，加载这些指令，并最终执行。
 - 执行指令的入口为zend_execute，传入参数为op_array以及一个zval指针，存储返回值：
```c
ZEND_API void zend_execute(zend_op_array *op_array, zval *return_value)
{
	zend_execute_data *execute_data;

	if (EG(exception) != NULL) {
		return;
	}

	execute_data = zend_vm_stack_push_call_frame(ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE,
		(zend_function*)op_array, 0, zend_get_called_scope(EG(current_execute_data)), zend_get_this_object(EG(current_execute_data)));
	if (EG(current_execute_data)) {
		execute_data->symbol_table = zend_rebuild_symbol_table();
	} else {
		execute_data->symbol_table = &EG(symbol_table);
	}
	EX(prev_execute_data) = EG(current_execute_data);
	i_init_code_execute_data(execute_data, op_array, return_value);
	zend_execute_ex(execute_data);
	zend_vm_stack_free_call_frame(execute_data);
}
```
 - 观察第一行，声明了一个zend_execute_data类型的指针，这个类型非常重要：
```c
struct _zend_execute_data {
	const zend_op       *opline;          //当前执行的指令
	zend_execute_data   *call;           //类似链表
	zval                *return_value;         //存储返回值
	zend_function       *func;              //执行的函数
	zval                 This;             /* this + call_info + num_args    */
	zend_execute_data   *prev_execute_data;
	zend_array          *symbol_table;
#if ZEND_EX_USE_RUN_TIME_CACHE
	void               **run_time_cache;   /* cache op_array->run_time_cache */
#endif
#if ZEND_EX_USE_LITERALS
	zval                *literals;         /* cache op_array->literals       */
#endif
};
```