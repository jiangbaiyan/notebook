# **【PHP源码学习】2019-03-27 Zend虚拟机**
baiyan

全部视频：https://segmentfault.com/a/1190000018488313

原视频地址：http://replay.xesv5.com/ll/2480/73533b76eb889194db9d5b922669f6c4.flv.mp4

## 复习
 - 首先复习几个基本概念：
 > **opline**：在zend虚拟机中，每条指令都是一个**opline**，每个opline由操作数、指令操作、返回值组成
 > **opcode**：每个指令操作都对应一个**opcode**（如ZEND_ASSIGN/ZEND_ADD等等），在PHP7中，有100多种指令操作，所有的指令集被称作opcodes
 > **handler**：每个opcode指令操作都对应一个**handler**指令处理函数，处理函数中有具体的指令操作执行逻辑
 - 我们知道，在经过编译阶段（zend_compile函数）中，我们生成AST并对其遍历，生成一条条指令，每一条指令都是一个opline。之后通过pass_two函数生成了这些指令所对应的handler，这些信息均存在op_array中。既然指令和handler已经生成完毕，接下来的任务就是要交给zend虚拟机，加载这些指令，并最终执行对应的handler逻辑。
 - 指令在PHP7中，由以下元素构成：
```c
  struct _zend_op {

      const void *handler; //操作执行的函数

      znode_op op1; //操作数1

      znode_op op2; //操作数2

      znode_op result; //返回值

      uint32_t extended_value; //扩展值

      uint32_t lineno; //行号

      zend_uchar opcode; //opcode值

      zend_uchar op1_type; //操作数1的类型

      zend_uchar op2_type; //操作数2的类型

      zend_uchar result_type; //返回值的类型

};
```
 - 在PHP7中，每个操作数有5种类型可选，如下：
```c
#define IS_CONST        (1<<0)

#define IS_TMP_VAR      (1<<1)

#define IS_VAR          (1<<2)

#define IS_UNUSED       (1<<3)   /* Unused variable */

#define IS_CV           (1<<4)   /* Compiled variable */
```
> IS_CONST类型：值为1，表示常量，如$a = 1中的1或者$a = "hello world"中的hello world
> IS_TMP_VAR类型：值为2，表示临时变量，如$a=”123”.time(); 这里拼接的临时变量”123”.time()的类型就是IS_TMP_VAR，一般用于操作的中间结果
> IS_VAR类型：值为4，表示变量，但是这个变量并不是PHP中常见的声明变量，而是返回的临时变量，如$a = time()中的time()
> IS_UNUSED：值为8，表示没有使用的操作数
> IS_CV：值为16，表示形如$a这样的变量
 - 对AST进行遍历之后，最终存放所有指令集（oplines）的地方为op_array：
```c
  struct _zend_op_array {

      uint32_t last; //下面oplines数组大小

      zend_op *opcodes; //oplines数组，存放所有指令

      int last_var;//操作数类型为IS_CV的个数

      uint32_t T;//操作数类型为IS_VAR和IS_TMP_VAR的个数之和

      zend_string **vars;//存放IS_CV类型操作数的数组

      ...

      int last_literal;//下面常量数组大小

      zval *literals;//存放IS_CONST类型操作数的数组

};
```
 - 为了复习op_array的存储情况，我们具体gdb一下，使用下面的测试用例：
```php
<?php
$a = 2;
```
 - 根据以上测试用例，在zend_execute处打一个断点，这里完成了对AST的遍历并生成了最终的op_array，已经进入到虚拟机执行指令的入口。首先我们先观察传入的参数op_array，它是经过AST遍历之后生成的最终的op_array：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/6/4/1559610483359.png)
 - last = 2;表示一共有两个opcodes：一个是赋值ASSIGN，另一个是脚本为我们自动生成的返回语句return 1，opcodes是一个数组，每个数组单元具体存储了每条指令的信息（操作数、返回值等等），我们打印一下数组的内容：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/6/4/1559610843967.png)
 - last_var = 1;表示有一个CV类型的变量，这里就是$a
 - T = 1;表示IS_TMP_VAR和IS_VAR变量类型的数量之和，而我们脚本中并没有这样的变量，它是在存储中间的返回值的时候，这个返回值类型就是一个IS_VAR类型，所以T的值一开始就为1
 - vars是一个二级指针，可以理解为外层的一级指针首先指向一个数组，这个数组里每个存储单元都是一个zend_string\*类型的指针，而每个指针都指向了一个zend_string结构体，我们打印数组第一个单元的值，发现其指向的zend_string值为a：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/6/4/1559611040076.png)
 - last_literal = 2;表示脚本中一共有2个常量，一个是我们自己复制的值2，另一个是脚本为我们自动生成的返回语句return 1中的值1：
 - literals是一个zend_array，里面每一个单元都是一个zval，存储这些常量的实际的值，我们可以看到，其值为2和1，与上面的描述相符：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/6/4/1559611299855.png)
 - 我们可以画出最终的op_array存储结构图：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/6/4/1559612762058.png)
 - 这样一来，我们就可以清晰地看出指令在op_array中是如何存储的。那么接下来，我们需要将其加载到虚拟机的执行栈桢上，来最终执行这些指令。
## 在虚拟机上执行指令
 - 下面让我们真正执行op_array中的指令，执行指令的入口为zend_execute函数，传入参数为op_array以及一个zval指针：
```c
ZEND_API void zend_execute(zend_op_array *op_array, zval *return_value)
{
	zend_execute_data *execute_data;

	if (EG(exception) != NULL) {
		return;
	}

	execute_data = zend_vm_stack_push_call_frame(ZEND_CALL_TOP_CODE | ZEND_CALL_HAS_SYMBOL_TABLE,
		(zend_function*)op_array, 0, zend_get_called_scope(EG(current_execute_data)), zend_get_this_object(EG(current_execute_data)));
	if (EG(current_execute_data)) {
		execute_data->symbol_table = zend_rebuild_symbol_table();
	} else {
		execute_data->symbol_table = &EG(symbol_table);
	}
	EX(prev_execute_data) = EG(current_execute_data);
	i_init_code_execute_data(execute_data, op_array, return_value);
	zend_execute_ex(execute_data);
	zend_vm_stack_free_call_frame(execute_data);
}
```
 - 观察第一行，声明了一个zend_execute_data类型的指针，这个类型非常重要，存储了虚拟机执行指令时的基本信息：
```c
struct _zend_execute_data {
	const zend_op       *opline;          //当前执行的指令
	zend_execute_data   *call;           //指向自己的指针
	zval                *return_value;         //存储返回值
	zend_function       *func;              //执行的函数
	zval                 This;             /* this + call_info + num_args    */
	zend_execute_data   *prev_execute_data; //链表，指向前一个zend_execute_data
	zend_array          *symbol_table;  //符号表
	...
};
```