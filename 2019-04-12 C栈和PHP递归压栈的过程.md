baiyan

全部视频：https://segmentfault.com/a/1190000018488313

## C语言函数调用压栈的过程
 - 我们都知道，函数调用的过程中，需要先进行压栈并保存当前函数调用的下一条指令的地址，待函数运行结束后，再回到原始函数的调用位置。那么我们举一个例子，来描述C语言函数调用压栈的模型：
```c
int bar(int c, int d){
    int e = c + d;
    return e;
}

int foo(int a, int b){
    return bar(a, b);
}

int main(void){
    foo(2, 5);
    return 0;
}
```
 - 在分析之前，我们首先需要了解几个计算机的概念：
### 寄存器
 - 寄存器就是CPU上的一块存储区域，存取速度比普通存储器高好几个数量级。为了提升程序运行的效率，程序运行期间产生的数据往往会存到寄存器中。
 - 寄存器的分类有多种：数据寄存器、变址寄存器、指针寄存器、段寄存器、指令指针寄存器、标志寄存器等，用于存储不同类型的数据，下面我们逐个介绍：
#### 数据寄存器
 - 数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。RAX、RBX、RCX、RDX和EAX、EBX、ECX、EDX以及AX、BX、CX、DX分别称为64位、32位、16位数据寄存器(通用寄存器)。
### 变址寄存器
 - 变址寄存器主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。 寄存器RSI、RDI和ESI、EDI和SI、DI分别称为64位、32位、16位变址寄存器(Index Register)。
#### 指针寄存器
 - 指针寄存器主要用于**存放堆栈内存的地址**，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。 寄存器**RBP、RSP**和EBP、ESP和BP、SP称分别为64位、32位、16位指针寄存器(PointerRegister)，它可分为两类：
（1）BP为基指针(BasePointer)寄存器，指向**栈底**，用它可直接存取堆栈中的数据； 
（2）SP为堆栈指针(StackPointer)寄存器，用它只可访问**栈顶**。
#### 段寄存器
 - 段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量值组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址，CS、DS、ES、SS、FS、GS。
#### 指令指针寄存器
 - 指令指针寄存器是存放**下一次将要执行的指令**在代码段的偏移量。在具有预取指令功能的系统中，下次要执行的指令通常已被预取到指令队列中，除非发生转移情况。所以，在理解它们的功能时，不考虑存在指令队列的情况。 **RIP**、EIP、IP(Instruction Pointer)分别为64位、32位、16位指令指针寄存器。
  - 我们重点关注这几个寄存器：RBP（栈底）/RSP（栈顶）、RIP（下次将要执行的指令）。
### 使用gdb查看压栈过程
 - 下面我们使用gdb的反汇编disassemble命令，来查看函数执行的栈桢情况：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/7/19/1563506221783.png)
 - 我们观察红框中的部分，当前正在执行main函数，还没有进行函数foo的调用，在序号10的两条指令还没有执行之前，当前栈桢的情况如下：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/7/19/1563510294308.png)
 - 寄存器RBP的值指向栈底，寄存器RSP的值指向栈顶，当前没有任何其它函数的入栈。
 - 执行push %rbp指令：将rbp寄存器的值入栈，是为了只有保存调用者（caller）的地址，后面执行完调用函数之后，才能正确返回。执行push指令后，栈顶指针需要随之移动，执行后的栈桢结构如下：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/7/19/1563510354835.png)
 - 执行mov %rsp,%rbp指令：将寄存器RSP的值赋到寄存器RBP中，执行后的栈桢结构如下：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/7/19/1563510380167.png)
 - 接下来序号11会首先使用变址寄存器ESI和EDI保存函数调用的参数值2和5，然后使用callq指令真正地进行函数调用，我们使用gdb的s命令进入foo函数调用的内部：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/7/19/1563510431221.png)
 - 观察序号6的前两个汇编指令，和之前的入栈操作一摸一样，我们直接画图：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/7/19/1563511158085.png)
 - 接下来观察第3条汇编指令：sub $0x8, %rsp ，它表示用RSP寄存器的值减去0x8，然后把结果赋值给RSP寄存器。由于栈的生长方向是从高地址到低地址，所以需要做减法，从而空出一段内存空间，做完sub操作的栈桢如下：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/7/19/1563511562342.png)
 - 接下来观察第4、5条汇编指令，他们将%edi和%esi寄存器中的值，拷贝到以rbp指针为起始位置，偏移-0x4与-0x8地址的位置。我们知道，之前在%edi和%esi变址寄存器中存放的就是调用函数foo时候的参数2和5，现在我们把这两个参数，也拷贝到函数foo的运行栈桢上了：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/7/19/1563511877363.png)