baiyan

全部视频：https://segmentfault.com/a/1190000018488313

## C语言函数调用压栈的过程
 - 我们都知道，函数调用的过程中，需要先进行压栈并保存当前函数调用的下一条指令的地址，待函数运行结束后，再回到原始函数的调用位置。那么我们举一个例子，来描述C语言函数调用压栈的模型：
```c
int bar(int c, int d){
    int e = c + d;
    return e;
}

int foo(int a, int b){
    return bar(a, b);
}

int main(void){
    foo(2, 5);
    return 0;
}
```
 - 在分析之前，我们首先谈几个计算机的概念：
### 寄存器
 - 寄存器就是CPU上的一块存储区域，存取速度比普通存储器高好几个数量级。
 - 寄存器的分类有多种：数据寄存器、变址寄存器、指针寄存器、段寄存器、指令指针寄存器、标志寄存器等，用于存储不同类型的数据，下面我们逐个介绍：
#### 数据寄存器
 - 数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。RAX、RBX、RCX、RDX和EAX、EBX、ECX、EDX以及AX、BX、CX、DX分别称为64位、32位、16位数据寄存器(通用寄存器)。
### 变址寄存器
 - 变址寄存器主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。 寄存器RSI、RDI和ESI、EDI和SI、DI分别称为64位、32位、16位变址寄存器(Index Register)。
#### 指针寄存器
 - 指针寄存器主要用于**存放堆栈内存的地址**，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。 寄存器**RBP、RSP**和EBP、ESP和BP、SP称分别为64位、32位、16位指针寄存器(PointerRegister)，它可分为两类：
（1）BP为基指针(BasePointer)寄存器，指向**栈底**，用它可直接存取堆栈中的数据； 
（2）SP为堆栈指针(StackPointer)寄存器，用它只可访问**栈顶**。
#### 段寄存器
 - 段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量值组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址，CS、DS、ES、SS、FS、GS。
#### 指令指针寄存器
 - 指令指针寄存器是存放**下次将要执行的指令**在代码段的偏移量。在具有预取指令功能的系统中，下次要执行的指令通常已被预取到指令队列中，除非发生转移情况。所以，在理解它们的功能时，不考虑存在指令队列的情况。 **RIP**、EIP、IP(Instruction Pointer)分别为64位、32位、16位指令指针寄存器。
  - 我们重点关注这几个寄存器：RBP（栈底）/RSP（栈顶）、RIP（下次将要执行的指令）
 - 下面我们使用gdb的反汇编disassemble命令，来查看函数执行的栈桢情况：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/7/19/1563506221783.png)
 - 我们观察红框中的部分，当前正在执行main函数，还没有进行函数foo的调用，在序号10的两条指令还没有执行之前，当前栈桢的情况如下：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/7/19/1563508427302.png)
 - 在main函数执行之前，会有一个_start初始化区域，寄存器RBP的值指向栈底，寄存器RSP的值指向栈顶，当前没有任何函数的入栈。
 - 执行push %rbp指令，将rbp寄存器的值入栈，是为了只有保存调用者（caller）的地址，后面执行完调用函数之后，才能正确返回。执行push指令后，栈顶指针需要随之移动，执行完毕后的栈桢结构如下：
![](http://baiyanzzz.oss-cn-beijing.aliyuncs.com/2019/7/19/1563508590797.png)